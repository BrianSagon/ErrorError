#VEXcode Generated Robot Configuration
from vex import *
import time

# Brain should be defined by default
brain=Brain()
speed = 1
# Robot configuration code
controller1 = Controller(PRIMARY)

# wait for rotation sensor to fully initialize
wait(30, MSEC)

#dictionary assignment, used for determining spin direction in the auto_move() class
    #numbers in here are used to signify if a motor will spin forward or backward, with 1 being forward and -1 being backward
move_direction = {}
move_direction["turn_right"] = {}
move_direction["turn_right"]["left_side"] = 1
move_direction["turn_right"]["right_side"] = -1

move_direction["turn_left"] = {}
move_direction["turn_left"]["left_side"] = -1
move_direction["turn_left"]["right_side"] = 1

move_direction["drive_forward"] = {}
move_direction["drive_forward"]["left_side"] = 1
move_direction["drive_forward"]["right_side"] = 1

move_direction["drive_backward"] = {}
move_direction["drive_backward"]["left_side"] = -1
move_direction["drive_backward"]["right_side"] = -1



#start of functions
class drive_train_class():
        def __init__(self):
            self.back_left=Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)
            self.front_left=Motor(Ports.PORT19, GearSetting.RATIO_18_1, False)
            self.back_right=Motor(Ports.PORT11, GearSetting.RATIO_18_1, True)
            self.front_right=Motor(Ports.PORT14, GearSetting.RATIO_18_1, True)
            self.right_puncher=Motor(Ports.PORT4, GearSetting.RATIO_36_1, False)
            self.left_puncher=Motor(Ports.PORT7, GearSetting.RATIO_36_1, True)
            self.left_wing=DigitalOut(brain.three_wire_port.h)
            self.right_wing=DigitalOut(brain.three_wire_port.g)
            self.puncher_group = MotorGroup(self.right_puncher, self.left_puncher)

        def left_motor_vspin(self, velocity):
            self.front_left.spin(FORWARD, velocity, PERCENT)
            self.back_left.spin(FORWARD, velocity, PERCENT)

        def right_motor_vspin(self, velocity):
            self.front_right.spin(FORWARD, velocity, PERCENT)
            self.back_right.spin(FORWARD, velocity, PERCENT)
        
        def motors_brake(self):
            self.front_left.stop(BRAKE)
            self.back_left.stop(BRAKE)
            self.front_right.stop(BRAKE)
            self.back_right.stop(BRAKE)

        def drive(self):
            global speed
            while True:
                self.speed_change_thread = Thread(self.speed_change)
                drive_train.left_motor_vspin(((controller1.axis3.position()+((controller1.axis1.position() * .7)/(1+abs(controller1.axis3.position()/100)))))*speed)
                drive_train.right_motor_vspin(((controller1.axis3.position()-((controller1.axis1.position() * .7)/(1+abs(controller1.axis3.position()/100)))))*speed)
                if abs(controller1.axis3.position()) < 1 and abs(controller1.axis1.position()) < 1:
                    self.motors_brake()
                wait(5, MSEC)

        def speed_change(self):
            global speed
            if controller1.buttonL2.pressing() == True:
                if speed == 1:
                    speed = .3
                elif speed == .3:
                    speed = 1
                wait(.75, SECONDS)

class auto_move():
        def move_to(self, forward, right, time_limit):
            turn_direction = "drive_forward"
            
            length = math.sqrt((forward ** 2) + (right ** 2))

            radians = 0
            if forward == 0:                 #I'm not adding a check for if both are zero, as that should never happen
                if right > 0:
                    radians = -math.pi/2
                    turn_direction = "turn_right" #All these define the direction that the wheel must turn, which calls upon a dictionary to determine if the right and left wheels should spin forward or backwards
                if right < 0:
                    radians = math.pi/2
                    turn_direction = "turn_left"
            elif right == 0:
                if forward > 0:
                    radians = 0
                    turn_direction = "drive_forward"
                if forward < 0:
                    radians = math.pi
                    turn_direction = "turn_right"          
            else:
                radians = abs((math.atan2(-right, forward))) #THIS IS IMPORTANT: Since i can't seem to remember how this works I'm explaining it here. Arctan by default supplies the 1st and 4th quadrants, however in order to get the full range of motion i need it all in either the 1st and 2nd or the 3rd and 4th (Arctan2!!!). I just use absolute value to turn all numbers into the 1st and 2nd quadrant, then i use turn_direction to determine where it should spin. A positive Forward shift in this case signifies a positive shift along the x-axis, while a positive right shift signifies a negative shift along the y axis (this is why the formula uses -right, effectively turning right into left)
                if right > 0:
                    turn_direction = "turn_right"
                if right < 0:
                    turn_direction = "turn_left"
            length_of_arc = 4.5518 * radians          #10 inches is the diameter between wheels of the robot, 5 inches is the radius   #Changed to 4.5518 as it seems to be more accurate, possibly because the back motors are pushing it forward as well.
            turns = length_of_arc/10.9        #10.99 is the circumference of the wheels
            degree = turns * 360

            if degree != 0:
                self.back_right_controller_thread = Thread(self.back_right_controller, (degree * move_direction[turn_direction]["right_side"], time_limit,))
                self.front_left_controller_thread = Thread(self.front_left_controller, (degree * move_direction[turn_direction]["left_side"], time_limit,))
                self.front_right_controller_thread = Thread(self.front_right_controller, (degree * move_direction[turn_direction]["right_side"], time_limit,))
                self.back_left_controller(degree * move_direction[turn_direction]["left_side"], time_limit,)

            Turns = (length*12)/12.2          #length is multiplied by 12 so that it is defined in inches rather than feet; the 12.566 is also in inches so multiplying it by 12 cancels them into just turns of the wheel
            degree = Turns * 360
            self.back_right_controller_thread = Thread(self.back_right_controller, (degree, time_limit,))
            self.front_left_controller_thread = Thread(self.front_left_controller, (degree, time_limit,))
            self.front_right_controller_thread = Thread(self.front_right_controller, (degree, time_limit,))
            self.back_left_controller(degree, time_limit,)

        def front_right_controller(self, degree, time_limit):
            #For all parts of this, velocity is in degrees/s and acceleration is in degrees/s^2
            drive_train.front_right.set_position(0)
            error = degree - drive_train.front_right.position()
            initial_seconds = time.time()
            acceleration = 100                                    
            velocity = 0
            initial_error = degree
            if abs(error/7.20) > 100: #100 is temporary for max acceleration that I want. 7.2 comes from 720 degrees in two rotations, divided by 100
                if error > 0:
                    acceleration = 100
                if error < 0:
                    acceleration = -100
            else: 
                acceleration = error/7.20
            #First third of movement: acceleration
            while (error/initial_error > .55) and (drive_train.front_left.velocity(RPM) < 197.5):    #197.5 is the lowest max speed of our robot (it's not a constant number :/)
                error = degree - drive_train.front_right.position()
                change_in_time = time.time() - initial_seconds
                velocity = .5*acceleration*(change_in_time**2)
                if velocity >= 0:
                    direction = FORWARD
                else:
                    direction = REVERSE
                drive_train.front_right.spin(direction, abs(velocity) * (1/6), RPM)  #1/6 is the conversion from degrees/s to rotations/minute

            #Second third of movement: constant speed
            time_needed_to_stop = velocity/acceleration
            time_left = (error*2)/velocity
            while time_needed_to_stop < time_left:
                time_left = (error*2)/velocity
                error = degree - drive_train.front_right.position()
                if velocity >= 0:
                    direction = FORWARD
                else:
                    direction = REVERSE
                drive_train.front_right.spin(direction, velocity * (1/6), RPM)

            #Third third of movement: deceleration
            

        def front_left_controller(self, degree, time_limit):
        
        def back_right_controller(self, degree, time_limit):
        
        def back_left_controller(self, degree, time_limit):


class game_class():
        def user_control(self):
            brain.screen.clear_screen()
            brain.screen.print("user control code")
            self.drive_thread = Thread(drive_train.drive)
            #User control code
            
        def autonomous(self):
            brain.screen.clear_screen()
            brain.screen.print("auton code")
            #auton code

        def pre_autonomous(self):
            brain.screen.clear_screen()
            brain.screen.print("pre auton code")


#class defining          
drive_train = drive_train_class()
game = game_class()


#Main
comp = Competition(game.user_control, game.autonomous)
game.pre_autonomous()
